---
title: JavaScript基础
date: 2019-1-16 11:39:01
tag: JavaScript核心
category: JavaScript
---
#### javaScript
- JavaScript是一种专为与网页交互而设计的脚本语言，由下列三个不同的部分组成： 
    - ECMAScript，由 ECMA-262定义，提供核心语言功能； 
    - 文档对象模型（DOM），提供访问和操作网页内容的方法和接口； 
    - 浏览器对象模型（BOM），提供与浏览器交互的方法和接口。 

##### 1. ECMAScript
- ECMAScript就是对实现该标准规定的各个方面内容的语言的描述。
- JavaScript实现了 ECMAScript， Adobe ActionScript同样也实现了 ECMAScript。ECMAS有很多种宿主，比如浏览器、NodeJS、AdobeFlash等
- 它规定了这 门语言的下列组成部分：
    - 语法 
    - 类型 
    - 语句 
    - 关键字 
    - 保留字 
    - 操作符 
    - 对象

###### JS文件嵌入和外部加载的区别：
    可维护性、可缓存、适应未来
###### ECAMS语法：`
    区分大小写
###### 标识符:
    就是指变量、函数、属性的名字，或者函数的参数;
    第一个字符必须是：字母、下划线（_）或一个美元符号（$）； 

###### 关键字：
```
break         
do           
instanceof        
typeof 
case          
else         
new               
var 
catch         
finally      
return            
void 
continue      
for          
switch            
while 
debugger*  
function     
this              
with 
default      
if           
throw 
delete       
in           
try
```
###### 变量定义：
    var message = ”666“; 
    1. 未经过初始化的变量，会保存一个特殊的值——undefined；
    2. 用var定义的变量是局部变量。
    3. 省略var定义的变量是全局变量。任何地方都可以引用。
    4. 给多个变量同时赋值:
        var message = "hi",     
        found = false,     
        age = 29; 

###### 数据类型：
- ECMAS定义了5种基本类型，String、Number、Boolean、Null、Undefined
- 1种复杂类型：Object，本质是由一组无序的key-value组成
- 常用引用类型：
    - Array:

        1. 判断一个某个对象是不是数组最好使用：Array.isArray()
        2. 转换方法：数组调用toString时，会调用数组每一项的toString方法，然后拼接成逗号分隔的字符串。但是可以通过数组的join方法改变分隔符。
        3. 栈方法(后进先出)：
            - push()：接收任意数量的参数，把他们逐个添加到数组**末尾**，并返回修改后数组的长度。
            - pop()：从数组**末尾**移除最后一项，减少length，并返回移除的项。
        4. 队列方法（先进先出）：
            - push()：同栈。
            - shift()：**移除数组中第一个项**，并返回该项，同时将数组长度减1。
            - unshift()：与shift用途相反，能**在数组的前端添加项**，并返回新数组的长度。tips：同时使用unshift和pop方法可以从相反的方向来模拟队列。
        5. 重排序方法：
            - reverse(): 逆置该数组
            - sort(): 默认按升序排列，为了实现排序，sort方法会调用每个数组项的toString方法，然后把得到的字符串按字典序进行排序。即使数组中的每一项都是数值，sort方法比较的也是字符串。如：
                ```
                var values = [0, 1, 5, 10, 15];
                values.sort();
                alert(values);
                //0,1,10,15,5
                // 因为“10”位于“5”的前面
                ----------------------------
                var a = ['1','2','5','10','15','21']
                a.sort()
                ["1", "10", "15", "2", "21", "5"]
                ```
            - 由以上可知，sort方法不靠谱，因此sort方法可以接受一个比较函数作为参数，以便我们指定那个值位于哪个值的前面。如：
                ```
                function compare(value1, value2) {
                    if (value1 < value2) {
                        return -1;
                    } else if (value1 > value2) {
                        return 1;
                    } else {
                        return 0;
                    }
                }
                ```
        6. 操作方法：
            - concat():方法可以基于当前数组中的所有项创建一个新数组。具体来说，这个方法会先创建当前数组一个副本，然后将接收到的参数添加到这个副本的末尾，最后返回新构建的数组。无参情况下，它只是复制当前数组并返回副本。如果传递给concat()方法的是一或多个数组，则该方法会将这些数组中的每一项都添加到结果数组中。如果传递的值不是数组，这些值就会被简单地添加到结果数组的末尾。
            
            - slice()：在只有一个参数的情况下，slice()方法返回从该参数指定位置开始到当前数组末尾的所有项。如果有两个参数，该方法返回起始和结束位置之间的项——但不包括结束位置的项。注意， **slice()方法不会影响原始数组**。
            
            - splice(): 
                - 删除：splice(起始位置，删除的项数)
                - 插入：splice（起始位置，0（要删除的项数），要插入的项）
                - 替换：splice（起始位置，要删除的项数，要插入的项数）；
                - 注：splice()方法始终都会返回一个数组，该数组中包含从原始数组中删除的项（如果没有删除任何
项，则返回一个空数组）
            7. 位置方法
                - indexOf()：从前往后，第一个参数为查找目标，可选接受第二个参数指定起始位置
                - lastIndexOf()：从后往前
                - 二者都返回要查找的目标的位置，如果查不到则返回-1
            8. 迭代方法
                - every()：对数组中的每一项运行给定函数，如果该函数对每一项都返回 true，则返回 true。
                - filter()：对数组中的每一项运行给定函数，返回该函数会返回 true 的项组成的数组。
                - forEach()：对数组中的每一项运行给定函数。这个方法没有返回值。
                - map()：对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。
                - some()：对数组中的每一项运行给定函数，如果该函数对任一项返回 true，则返回 true。
                - **每个方法都接收两个参数：要在每一项上运行的函数和
（可选的）运行该函数的作用域对象——影响 this 的值。传入这些方法中的函数会接收三个参数：数
组项的值、该项在数组中的位置和数组对象本身。**
            9. 归并方法
                - reduce():
                - reduceRight()
            10. Array对象拥有length方法，且该length是可写的。
    - Object：
        1. 常用函数：
            - valueOf()    //  返回对象的字符串、数值或布尔值表示
返回一个对象对应的基本类型字面量值,无法转换的直接返回对象本身。
            - toString() //
            - hasOwnProperty(propertyName) // 不检查原型链
            - isPrototypeOf(object) // 检查传入的对象是否是传入对象的原型
    - Date：
    - RegRex：
    - Function：
        1. 每个函数都是Function类型的实例，而且都与其他引用类型一样具有属性和方法。由于函数是对象，因此函数名实际上也是一个指向函数对象的指针，不会与某个函数绑定，
        2. 函数声明与函数表达式与Function构造函数：
            - 解析器会率先读取函数声明，并将其提升执行环境顶部，使其在执行任何代码前可用；
            - 函数表达式必须等到解析器执行到他所在的代码航才会真正的被执行。
            - var sum = new Function("num1","num2","return num1 + num2");
        3. 没有重载（重载是方法签名不同，即拥有不同的参数个数和类型，而JS中参数是以一个数组的形式接收的）
        4. 函数体内部可以使用的两个特殊对象：arguments和this
            - arguments是一个类数组对象，包含着传入函数中的所有参数，访问方式为：
                ``` 
                第一个元素是 arguments[0]，第二个元素是argumetns[1]，以此类推
                使用 length 属性来确定传递进来多少个参数。
                ```
            - arguments还保存着一个名叫callee的属性，该属性是一个指针，**指向拥有这个arguments对象**的函数：
                ```
                function factorial(num){
                    if (num <=1) {
                    return 1;
                    } else {
                    return num * arguments.callee(num-1)
                    }
                }
                ```
            - this：this 引用的是**函数据以执行的环境对象**---或者说是this的值，**当在全局作用域中调用函数时，this对象引用的就是window。**
                - 执行环境：简称环境，它定义了变量或函数有权访问的其他数据，决定了他们各自的行为，每个环境都有一个与之关联的**变量对象**,环境中定义的所有变量和函数都保存在这个对象中，**代码无法访问这个对象**,但解析器在后台使用它解析数据。
                - 全局执行环境是最外围的一个执行环境。在web浏览器中，它是window对象，**因此所有全局变量和函数都是作为window对象的属性和方法创建的。**
                - 作用域链：
                    1. 每个函数都有自己的**执行环境**，当执行进入一个函数时，函数的环境就会被推入一个环境栈中。
                    2. 当代码在一个环境中执行时，会创建变量对象的一个**作用域链**。
                    3. 作用域链的作用是保证对执行环境有权访问的所有变量和函数的有序访问，**作用域链的前端始终都是当前执行代码所在的环境对象。**
                    4. 如果这个环境是函数，则将其**活动对象**作为环境对象,活动对象在最开始时只包含一个变量，即arguments对象（这个对象在全局环境中是不存在的）。
                    5. **作用域链中的下一个变量对象来自包含（外部）环境**，而再下一个变量对象则来自下一个包含环境，这样一直延续到全局的执行环境；全局执行环境的变量对象始终都是作用域链中的最后一个对象。
                    6. 标识符解析就是沿着作用域链一级一级的搜索标识符的过程，搜索过程始终从作用域链的前端开始，逐级的向后回溯，直到找到为止。
                - **关系整理**：
                    1. 执行环境和作用域是完全两个不同的概念
                    2. 函数的每次调用都有与之相关的作用域和执行环境，从根本上说，**作用域是基于函数的，执行环境是基于对象的**。
                    3. **作用域涉及到被调用函数的变量访问**，并且同一个函数不同的调用场景下作用域都是不一样的。
                    4. 执行环境始终是this关键字的值。他拥有当前所执行代码所属对象的引用。
                    5. **每个执行环境都有一个与之关联的变量对象**，环境中定义的所有变量和函数都保存在这个对象中。
                    6. **作用域链把从子到父再到全局作用域的执行环境的变量对象串起来。**
                    7. 变量对象和this的关系：
                        - this始终指向调用函数的那个对象。
                        - 
                    8. 所谓变量提升就是把一个作用域里面的变量和函数的声明信息放进该作用域最顶上。
        5. 函数的属性和方法：
            - 属性：
                - **prototype**：对于ECMAScript 中的引用类型而言， prototype是保存它们所有实例方法的真正所在。换句话说，诸如toString()和valueOf()等方法实际上都保存在 prototype 名下，只不过是通过各自对象的实例访问罢了
                - length：函数希望接收的参数个数
            - 方法：用于**改变函数执行的作用域**，即上下文环境。
                - call():一个是指定的作用域，后面的是逐个列举的参数。
                - apply():接受两个参数，第一个是指定的作用域，第二个是一个参数数组（或者是arguments对象）。
                    > 使用 call()（或apply()）来扩充作用域的最大好处，就是对象不需要与方法有任何耦合关系。
                    
                    > 当需要借用某个对象的方法，该方法与其所属对象有较强耦合关系，即该方法需要操作this
                    
                - bind():会创建一个函数的实例，并且将它的this绑定到传递给bind的值。
        6. 函数的执行过程和作用域：（搞清楚: 变量对象、活动对象、作用域链）
            1. 每个执行环境都有一个表示变量的对象----变量对象。
            2. 全局变量对象始终存在，局部环境的变量对象只在函数执行的过程中存在。
            3. 创建局部函数的时候，会创建一个预先包含全局变量对象的作用域链，这个作用域链被保存在内部的[[Scope]]属性中。
            4.当调用局部函数时，会为函数创建一个执行环境
            5. 然后通过复制函数的[[Scope]]属性中的对象，构建起执行环境的作用域链
            6. 此后，又有一个活动对象（在此作为变量对象使用）被创建并被推入执行环境作用域链的前端。
            7. 作用域链本质上是一个指向变量对象的指针列表，他只引用但不实际包含变量对象。
    - 基本包装类型(String Number Boolean)：
        - 实际上，每当读取一个基本类型值的时候，后台就会创建一个对应的基本包装类型的对象，从而让我们能够调用一些方法来操作这些数据。即：通过字面量创建的对象在调用属性和方法时会被对象包装器暂时包装成一个对象，具有对象的性质。
            ```
            (1) 创建一个对应包装类的一个实例;
            (2) 在实例上调用指定的方法 ;
            (3) 销毁这个实例。
            ```
        - 基本包装类型和引用类型的区别：
            ```
            1. 引用类型与基本包装类型的主要区别就是对象的生存期。
            2. 使用 new 操作符创建的引用类型的实例，在执行流离开当前作用域之前都一直保存在内存中。
            3. 而自动创建的基本包装类型的对象，则只存在于一行代码的执行瞬间，然后立即被销毁。
            4. 这意味着我们不能在运行时为基本类型值添加属性和方法
            ```
            下面的例子：
            ```
            var s1 = "some text";
            s1.color = "red";
            alert(s1.color); //undefined
            ```
        - 基本类型的包装类在使用typeof操作符时会像其它实例对象一样，返回object，使用instanceof可以得到正确的类型。
        - Object的构造方法就像一个工厂一样，根据传入的参数的类型返回对应的包装类实例。 
        - Boolean类
            > var b = new Boolean(true/false);
            
            - 同时重写了valueof方法，对Boolean的实例返回**基本类型**ture或false，也重写了toString方法，返回**字符串**true或false。
            - 布尔表达式中的所有对象都会被转换为 true。
        - String类：
            - 有个length属性，表示多少字符。
            - 字符访问方法：
                - charAt(index):输出指定位置的字符
                    > 等价于 "***"[index]
                    
                - charCodeAt(index):输出指定位置字符的编码
            - 字符操作方法：
                - concat():A.concat(B, ...),返回拼接后的字符串
                    > 一般用‘+’代替了
                    
                - slice：
                - substring：
                - substr：
                    ```
                    1. 以上三个方法都时基于已有字符串创建新的字符串
                    2. slice和substring有两个参数：第一个是起始位置，第二个是指定的是子字符串**最后一个字符后面的位置**
                    3. substr的第二个参数指返回的字符串个数。
                    ```
                - trim(): 返回一个副本，删除原字符串前缀和后缀的所有空字符串- toLowerCase(),toUpperCase()
            - 字符串的模式匹配方法
                - match(),本质上与RegExp的exec方法相同，match接受一个参数，要么是RegExp对象，要么是一个正则表达式。
                     > 返回的是一个数组。数组的第一项是与整个模式匹配的字符串，之后的每一项（如果有）保存着与正则表达式中的捕获组匹配的字符串。
                
                ```
                ["j", index: 2, input: "2ajlkfljksafjk", groups: undefined]
                
                注意：有没有多个匹配看你这个则表达式的flag的设置:
                    g（全局匹配）/i（忽略大小写）/m（多行）的组合
                ```
        - Number：
            - 重写了toString和valueof方法
            - toFixed(n)方法会按照指定的小数位返回数值的字符串表示
    - 单体内置对象：
        - 内置对象的定义是：
            >“由 ECMAScript实现提供的、不依赖于宿主环境的对象，这些对象在ECMAScript程序执行之前就已经存在了。”意思就是说，开发人员不必显式地实例化内置对象，因为它们已经实例化了.
            
        - 除了Global和Math对象外，Number、String、Boolean、Array、Object、Date、Function、GMT类型的**实例**也是单体内置对象。他们的属性和方法可以直接使用。
         
        - Global   
            > Global和Math是纯粹的对象，没有构造函数，也无法实例化新的对象。所有在全局作用域里面声明的变量和方法都是Global对象的属性。
            
            > 只有Global和Math可以直接使用Global.***  /Math.***；其余的只能是在实例化的对象中调用属性和方法，即他们的属性和方法属于其构造函数。

            - Global的属性：Infinity、NaN、Undefined
            - Global的方法：
                - encodeURI(URIString)/decodeURI():把字符串（完整的urlString）作为URI进行编码/解码；
                    ```
                    1. 该方法不会对 ASCII 字母和数字进行编码，也不会对这些 ASCII 标点符号进行编码： - _ . ! ~ * ' ( ) 。
                    2. 该方法的目的是对 URI 进行完整的编码，因此对以下在 URI 中具有特殊含义的 ASCII 标点符号，encodeURI() 函数是不会进行转义的：;/?:@&=+$,#
                    3. 提示：如果 URI 组件中含有分隔符，比如 ? 和 #，则应当使用 encodeURIComponent() 方法分别对各组件进行编码。
                    ```
                - encodeURIComponent/decodeURIComponent:对（部分urlString）进行编码和解码；
                - parseInt(string, radix):
                    解析一个字符串，并返回一个整数。radix是**要解析数字的基数**。
                - parseFloat(string): 解析一个字符串，返回一个浮点数
                - isFinite(number)：检测是否无穷大
                - isNaN(number):是否非数字
                - Number(oject)
                - String(object)
    
    
#### 面向对象的程序设计
    
##### 1.理解对象（配置属性的特性）
- ECMA定义内部采用的特性时，顺道描述了**对象的属性**的各种特征。
- 这些特性是内部值，JS中不能访问，*规范*把他们放在了两对括号中，如[[Enumerable]]
- 属性可以分为两类：
    - 数据属性：有四个描述其行为的特征：
        - [[configurable]]:默认值为true
        - [[Enumerable]]:默认为true，表示能否使用for-in
        - [[Writable]]:默认为true，表示能否修改属性
        - [[value]]:**默认为undefined**，用于记录属性的值
    - 访问器属性：

##### 2.创建对象
- 工厂模式
- 构造函数模式
- 原型模式
- 组合使用构造函数和原型模式
- 动态原型模式
- 寄生构造函数
- 稳妥构造函数

##### 3.继承
- 构造函数、原型对象、实例的关系：（P163、P164 [JavaSrcipt高级程序设计3]()）
    - 每个**构造函数**都内置一个属性prototype，指向其原型对象。
    - 每个**实例**都有一个[[Prototype]],指向其构造函数的原型对象。
    - **原型对象**有一个属性constructor，指向该原型对象的构造函数。
    - 可以通过给构造函数的原型对象赋值（用父类的实例），即重写子类的原型对象，这样子类就拥有了父类所有的属性和方法（通过父类实例获得,这样将导致子类的原型对象中没有constructor属性，不过可以手动添加。），同时，借助父类实例中的[[Prototype]],子类可以向上找到父类的原型对象。
        
    
    
#### 闭包、匿名函数、块级作用域、立即执行函数
- 闭包和匿名函数：匿名函数就是没有名字的函数（函数表达式、作为对象的value部分），闭包就是可以访问一个函数作用域里变量的**函数**（名字可有可无）。
- 由于JS只有函数作用域和全局作用域，因此声明在一些执行块中的变量（如for循环）只有在其所属函数体执行完毕才会释放，这可能会对函数内的变量造成一定干扰。
- 为了解决这个问题，可以将需要排除干扰的部分用一个新的function包围起来，这样被包裹的部分就就形成了一个新的函数作用域。
- 但是一个新的function并不会自己执行，即存放在里面的代码不能得到执行，因此有了**立即执行函数**。既保留了函数作用域，又得到了执行。
- 这样形成的函数具有访问其所处执行环境（函数）里面的变量的能力，故被称为**闭包**。
- 由于闭包会携带包含它的函数的作用域，因此也就具备了持久访问包含它的函数的作用域（变量对象）的能力。[P180图]()
- 由于闭包保存的有包含其的函数的变量对象，并且，当调用闭包时，包含它的函数已经返回，因此变量对象的值也已经确定下来，即为最终返回时的状态。
- 每个函数都有一个作用域链，最前面*(index为0)*存放的是当前活动对象,接着是父级函数的变量对象。
- function里面再声明一个function（函数声明式）,在函数体外无法访问第一个（父）function的作用域，因此声明在里面的函数（第二个function）无法在外部调用，并且也不会自己执行，对外部而言没有任何意义，不过可以在内部使用。
- function里面嵌入函数表达式，类似与在函数内部声明变量，同样在外面无法访问，

    
    
##### 2. DOM


##### 3. BOM
- window对象具有双重角色，既是通过JavaScript访问浏览器窗口的一个接口，又是ECMAScrip规定的Global对象。
- 所有在全局作用域中声明的变量和函数都会成为window对象的属性和方法。
- 窗口关系及框架：
    - 如果页面包含框架，则每个框架都有自己的window对象，并且保存在frames集合中。
    - top对象始终指向最高层的框架，也就是说浏览器窗口
    - parent对象始终指向当前框架的直接上层框架
    - self对象指向window
- 窗口位置：
    - window.screenLeft window.screenTop （除了firefox）
    - window.screenX  window.screenY  
- 窗口大小：
    - innerWidth innerHeight  outerWidth  outerHeight
- 文档区域：
    - **document.documentElement.clientWidth和document.documentElement.clientHeight指浏览器当前窗口的视图区域，不包括工具栏滚动条等的实际宽高。**
    - **document.documentElement.scrollWidth和document.documentElement.scrollHeight指浏览器body页面的大小，即网页整体大小。**
    - document.body.scrollTop和document.body.scrollLeft是指整个网页的上方或者左边被卷起来的部分。(for:IE9及更早版本)；其他情况可以使用**window.pageXOffset和window.pageYOffset代替**。
    - 可以通过document.ducumentElement.scrollHeight - document.body.scrollHeight得到
- 窗口区域：
    - window.screen.width和window.screen.height指整个显示器屏幕大小的宽高
    - window.screenTop和window.screenLeft是浏览器窗口顶部/左端距离屏幕边缘的部分
    - window.innerHeight和window.innerWidth是指当前窗口的可视区域，包括滚动条的宽高，不包括工具栏（注意与document.documentElement.clientWidth/Height的区别）